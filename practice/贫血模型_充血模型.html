<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title></title><meta name="description" content="">
    <link rel="modulepreload" href="/assets/app.d740ecc1.js"><link rel="modulepreload" href="/assets/贫血模型_充血模型.html.2b344102.js"><link rel="modulepreload" href="/assets/贫血模型_充血模型.html.733f2902.js">
    <link rel="stylesheet" href="/assets/style.c1f02812.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><!----></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/practice/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B_%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.html#引入" class="router-link-active router-link-exact-active sidebar-item" aria-label="引入"><!--[--><!--]--> 引入 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/practice/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B_%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.html#mvc架构" class="router-link-active router-link-exact-active sidebar-item" aria-label="MVC架构"><!--[--><!--]--> MVC架构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/practice/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B_%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.html#贫血模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="贫血模型"><!--[--><!--]--> 贫血模型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/practice/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B_%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.html#充血模型" class="router-link-active router-link-exact-active sidebar-item" aria-label="充血模型"><!--[--><!--]--> 充血模型 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/practice/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B_%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.html#设计思路的区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="设计思路的区别"><!--[--><!--]--> 设计思路的区别 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/practice/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B_%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.html#电子钱包的设计" class="router-link-active router-link-exact-active sidebar-item" aria-label="电子钱包的设计"><!--[--><!--]--> 电子钱包的设计 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/practice/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B_%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.html#总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h2 id="引入" tabindex="-1"><a class="header-anchor" href="#引入" aria-hidden="true">#</a> 引入</h2><p>最近学习了王争的MVC架构和OOP的相关知识，学习到了贫血模型和充血模型的相关知识。</p><h2 id="mvc架构" tabindex="-1"><a class="header-anchor" href="#mvc架构" aria-hidden="true">#</a> MVC架构</h2><p>在Java后台中，MVC架构是一种常见的系统架构，其核心目的在我看来是为了解耦。M-model，V-view，C-controller，另外MVC对于不同的项目和业务而言并没有非常严格的限制，在前后分离的项目中，对于后台而言，MVC一般分为为DAO（Repository）、Service、Controller。</p><h2 id="贫血模型" tabindex="-1"><a class="header-anchor" href="#贫血模型" aria-hidden="true">#</a> 贫血模型</h2><p>举个例子来讲，User、UserDAO作为数据访问层，UserBO、UserService作为业务逻辑层，UserVO、UserController作为接口层；其中UserBO只作为纯粹的数据结构，没有业务处理，业务逻辑集中在Service中。像UserBO这样的纯数据结构的就可以称之为贫血模型，同样的还有User和UserVO，这样的设计破坏了Java面向对象设计的封装特性，属于面向过程的编程风格。</p><h2 id="充血模型" tabindex="-1"><a class="header-anchor" href="#充血模型" aria-hidden="true">#</a> 充血模型</h2><p>基于充血模型的DDD开发模式，与贫血模型相反的是，充血模型将数据和业务放在一个类里面。DDD领域驱动设计，DDD核心是为了根据业务对系统的服务进行拆分。领域驱动设计的核心还是基于对业务的理解，不能一味追求这样的概念。对于充血模型的开发的MVC架构，其核心区别在于Service层：包含Domain类和Service类。Domain对于BO而言，添加了一定的业务逻辑，降低Service中的业务逻辑量。那么充血模型对于贫血模型好在哪里呢？对于贫血模型而言，由于数据和业务的分离，数据在脱离业务的情况下可以被任务程序修改，数据操作将不受限制等。为什么贫血模型这么盛行？一是对于大部分业务而言都比较简单，基本上都是围绕SQL的CRUD操作，仅仅通过贫血模型设计就可以完成业务。而是充血模型的设计难度较大。</p><h3 id="设计思路的区别" tabindex="-1"><a class="header-anchor" href="#设计思路的区别" aria-hidden="true">#</a> 设计思路的区别</h3><p>前者通常是在拿到需求后，先根据数据库表建立Modle，然后Servcie、Controller等进行代码填充，其中一个很重要的核心就是SQL，对于这个需求而言，大部分业务都是围绕这简单亦或复杂的SQL来完成的，当这个模块需要其它功能的时候，往往都是在基础上添加SQL来实现的。这样就会导致其中有很大一部分代码产生冗余，随着业务的深入，将会有大量类似的SQL出现在系统中。在这个过程中，基本上就忽略了DDD开发模式，失去了很多代码复用的机回。 基于充血模型的DDD开发模式下，首先需要根据业务，定义领域模型所包含的数据和方法，相当于设计可复用的业务中间层。对于之后的新功能的开发，都将基于这些已经定义好的领域模型来开发。两者很大的区别就在于后者会花费更多的时间在领域模型设计上。</p><h3 id="电子钱包的设计" tabindex="-1"><a class="header-anchor" href="#电子钱包的设计" aria-hidden="true">#</a> 电子钱包的设计</h3><h4 id="业务背景" tabindex="-1"><a class="header-anchor" href="#业务背景" aria-hidden="true">#</a> 业务背景</h4><ol><li>充值</li></ol><ul><li>用户银行卡金额A转到系统的公共银行卡</li><li>用户虚拟钱包： +A</li><li>记录流水 ：充值+A</li></ul><ol><li>支付</li></ol><ul><li>用户虚拟钱包 转账A 到商家的虚拟钱包</li><li>公共银行卡 转账A 到商家的银行卡</li><li>记录流水： 支付-A</li></ul><ol><li>提现</li></ol><ul><li>用户虚拟钱包 -A</li><li>公共银行卡 转账-A 到用户银行卡</li><li>记录流水： 提现-A</li></ul><ol><li>查询余额</li></ol><ul><li>查询用户虚拟钱包</li></ul><ol><li>交易流水</li></ol><ul><li>在每次交易的时候记录，只需要查询即可</li></ul><p>根据以上业务，可以将系统拆分为虚拟钱包和三方支付两个模块。下面着重思考虚拟钱包的设计。 对于上述所有的业务都需要一个操作，就是交易流水的记录。对于该功能的数据库表设计有两种思路：</p><ol><li>数据冗余，强一致性 表：流水ID、交易时间、交易类型（充值提现支付）、交易金额、入账账户、出账账户</li><li>无数据冗余，非强一致性 表：流水ID、交易时间、交易类型（充值、提现、支付、被支付）、交易金额、交易账户</li></ol><p>以上两种哪种更好呢？答案是第一种，因为在交易流水业务中，保证数据一致性是非常重要的，为了保证支付过程中数据的一致性，可以通过数据库事务来处理，但是这样不够灵活，比如分库分表没有办法直接利用数据库的事务来处理。虽然有一些开源的分布式事务框架，但是更权衡的来说，这里我们只需要保证结果的一致性，不需要保证过程的一致性：在支付的时候，先记录一条流水，标记为待执行，然后再去执行钱包的加减操作，当双方都执行完成后，再去把流水标记为已完成，如果任何一方操作失败，流水记录都将被标记为失败。这样就能保证交易流水结果的强一致性。对于上述两种设计，如果采取第二种思路，一次支付需要记录两条流水，对于这个行为而言本身就需要保持一致性，所以第一种更好，即使它存在一定的数据冗余的弊端。</p><h4 id="虚拟钱包系统" tabindex="-1"><a class="header-anchor" href="#虚拟钱包系统" aria-hidden="true">#</a> 虚拟钱包系统</h4><p>对于虚拟钱包系统而言，他不应该感知交易类型，它只负责金额的加加减减，但是为了交易流水的查询功能，又不得不需要这些信息，所以为了能够保持最基本的操作的复用性，我们单独剥离出这个系统，在这个系统以外再添加一个记录交易流水类型的表。</p><ul><li>钱包交易流水：交易流水ID、时间、金额、交易类型（充值、提现、支付）、入账账号、出账账号、虚拟钱包流水ID</li><li>虚拟钱包交易流水：交易流水ID、时间、金额、类型（加、减）、虚拟钱包账号、钱包交易流水ID</li></ul><p>对于虚拟钱包交易流水而言，它只服务于保持数据一致性上。</p><h4 id="基于贫血模型的传统开发模式" tabindex="-1"><a class="header-anchor" href="#基于贫血模型的传统开发模式" aria-hidden="true">#</a> 基于贫血模型的传统开发模式</h4><p>其核心在于Service层：VirtualWalletBo、VirtualWalletService</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>public class VirtualWalletBo{
	Long id;
	LocalDateTime createTime;
	BigDecimal balance;
}
public class VirtualWalletService{
	VirtualWalletDAO  dao;
	VirtualWalletTransactionDAO transactionDAO;
	public VirtualWalletBo get(Long id){
	    //根据id查数据库VirtualWalletEntity,转为bo 
	}
	publicBigDecimalgetBalance(LongwalletId){
	   return dao.getBalance(walletId);
	}
	public void debit(Long id,BigDecimal amount){
	    //记账
	    //更新账户金额
	}
	public void credit(Long id,BigDecimal amount){
	    //存钱
	    //更新账户金额
	}
	public void transfer(Long fromId,Long toId,BigDecimal amount){
	    //创建流水(记录为待执行):VirtualWalletTransactionEntity
	    debit(fromId,amount);
	    credit(toId,amount);
	    //更新流水状态为完成
	}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>上面的基本上包含了钱包的所有操作:存\取\流转\查</p><h4 id="基于充血模型的ddd开发模式" tabindex="-1"><a class="header-anchor" href="#基于充血模型的ddd开发模式" aria-hidden="true">#</a> 基于充血模型的DDD开发模式</h4><p>在这种开发模式下,将VirtualWallet类设计成一个充血的Domain领域模型,并将原来在service种的部分业务逻辑放到VirtualWallet类中,让Service类的实现依赖VirtualWallet类.</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>public class VirtualWallet{//Domain
    Long id;
    LocalDateTime createTime = LocalDateTime.now();
    BigDecimal balance = BigDecimal.ZERO;
    // get set
    public void debit(BigDecimal amount){
	//判断等相关操作
       this.balance.substract(amount);
    }
    public void credit(BigDecimal amount){
	this.balance.add(amount);
    }
}
在Service中仍然还是那些方法,不过记账存钱都调用Domain中的方法,其它方法保持不变.
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>事实上此时Domain类很单薄,只有两个业务:记账存钱,不过其设计思路在扩充业务逻辑的时候就能体现这样设计的优势了,比如冻结\透支等业务的加入,这时候Domain就没有那么单薄了.</p><h4 id="思考和灵活运用" tabindex="-1"><a class="header-anchor" href="#思考和灵活运用" aria-hidden="true">#</a> 思考和灵活运用</h4><ol><li>既然Domain已经加入了业务,为什么还要Service呢?</li></ol><ul><li>Service类负责与DAO交流,通过DAO获取数据库数据转化为Domain,然后由该领域模型来完成业务,最后调用DAO将数据存回数据库.事实上,Service是为了保持Domain不与任何其他层的的代码或者框架耦合在一起,将流程性的代码逻辑(比如从DB取数据,映射数据)与领域模型的业务逻辑解耦,让其更加可复用.</li><li>Service类负责跨领域模型的业务聚合功能</li><li>Service类负责一些非功能性以及与三方系统交互的工作.</li></ul><ol><li>为什么Controller和DAO层不进行充血模型设计呢? 没有必要.因为对于这两部分的业务功能都比较简单,贫血模型设计就能完成业务需求.尽管这样作为一种面向过程的编程风格,其副作用也能被大幅度降低.</li></ol><ul><li>DAO层的Entity:由于其生命周期是有限的,一般来讲被传递到Service之后就会被转化为BO或Domain来继续后面的业务,所以其数据安全性也没有什么问题.</li><li>Controller层的VO:VO实际上是一种DTO(数据传输对象),主要作用是作为接口的数据传输载体.从功能上来说,它不包含业务逻辑</li></ul><p>所以上述两层设计成贫血模型也是比较合理的.</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service层。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。 在基于充血模型的 DDD 开发模式下，Service 类并不会完全移除，而是负责一些不适合放在 Domain 类中的功能。比如，负责与 Repository 层打交道、跨领域模型的业务聚合功能、幂等事务等非功能性的工作</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 32995330+zongkx@users.noreply.github.com">zongkx</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.d740ecc1.js" defer></script>
  </body>
</html>
